import json
import requests
import asyncio
import os
import ntplib
from time import ctime, sleep
from pyrogram import filters, idle
from pyrogram.types import Message
from pyrogram import Client
from pyromod import listen
from fpdf import FPDF
import random
import string

bot = Client(
    "xrpminerbot",
    api_id=22363963,
    api_hash="5c096f7e8fd4c38c035d53dc5a85d768",
    bot_token="7261854045:AAGv8_bgcspRJ_LAMJjwaX_AAe8dSGMXEo4"
)

user_data = {}

def sync_time():
    try:
        ntp_client = ntplib.NTPClient()
        response = ntp_client.request('pool.ntp.org')
        os.system(f"date -s '{ctime(response.tx_time)}'")
        print("System time synchronized successfully.")
    except Exception as e:
        print(f"Failed to synchronize time: {e}")

def parse_cookies(cookie_string):
    cookies_dict = {}
    cookies = cookie_string.split(";")
    for cookie in cookies:
        if "=" in cookie:
            key, value = cookie.strip().split("=", 1)
            cookies_dict[key] = value
    return cookies_dict

def validate_and_fetch_user_info(cookie_string):
    session = requests.Session()
    session.headers.update({
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Content-Type': 'application/json',
        'Sec-Fetch-Dest': 'empty',
        'Sec-Fetch-Site': 'same-origin',
        'Sec-Fetch-Mode': 'cors',
        'Host': 'faucetearner.org',
        'Origin': 'https://faucetearner.org',
    })
    session.cookies.update(parse_cookies(cookie_string))

    try:
        response = session.get('https://faucetearner.org/api.php?act=faucet')

        if response.status_code == 200:
            try:
                user_info = response.json()
                email = user_info.get("email", "N/A")
                username = user_info.get("username", "N/A")
                return {"email": email, "username": username}
            except json.JSONDecodeError:
                return {"error": f"Invalid response format (expected JSON): {response.text}"}
        else:
            return {"error": f"HTTP Error: {response.status_code} - {response.text}"}
    except Exception as e:
        return {"error": f"Exception during login validation: {e}"}

def fetch_xrp_balance(cookie_string):
    session = requests.Session()
    session.headers.update({
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Content-Type': 'application/json',
        'Sec-Fetch-Dest': 'empty',
        'Sec-Fetch-Site': 'same-origin',
        'Sec-Fetch-Mode': 'cors',
        'Host': 'faucetearner.org',
        'Origin': 'https://faucetearner.org',
    })
    session.cookies.update(parse_cookies(cookie_string))

    try:
        # Validate by posting to withdraw.php
        post_data = {
            'act': 'withdraw',
            'cookie': cookie_string  # Assuming the session cookie is valid
        }
        response = session.post('https://faucetearner.org/withdraw.php', data=post_data)

        if response.status_code == 200:
            # If successful, fetch withdrawal details
            withdrawal_response = session.get('https://faucetearner.org/api.php?act=withdraw')

            if withdrawal_response.status_code == 200:
                try:
                    balance_info = withdrawal_response.json()
                    withdrawal_amount = balance_info.get("withdrawal_amount", 0)
                    total_balance = balance_info.get("total_balance", 0)
                    return {"withdrawal_amount": withdrawal_amount, "total_balance": total_balance}
                except json.JSONDecodeError:
                    return {"error": f"Invalid response format for balance: {withdrawal_response.text}"}
            else:
                return {"error": f"Error fetching balance: {withdrawal_response.status_code} - {withdrawal_response.text}"}
        else:
            return {"error": f"Error during withdrawal validation: {response.status_code} - {response.text}"}
    except Exception as e:
        return {"error": f"Exception during balance retrieval: {e}"}

class CustomPDF(FPDF):
    def __init__(self, chat_id, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.chat_id = chat_id
        self.add_font("DejaVuSans", "", "assets/DejaVuSans.ttf", uni=True)

    def header(self):
        self.set_font('DejaVuSans', '', 12)
        first_name = user_data.get(self.chat_id, {}).get('first_name', 'Unknown')
        header_text = f"FIRST NAME: {first_name}   User ID: {self.chat_id}   PDF ID: {generate_pdf_id()}"
        self.cell(0, 10, txt=self._sanitize_text(header_text), ln=True, align='C')
        self.ln(10)

    def footer(self):
        self.set_y(-30)
        self.set_font('DejaVuSans', '', 10)
        footer_text = "Report generated by XRP Miner Bot - Created by Nobitha"
        self.cell(0, 10, txt=self._sanitize_text(footer_text), ln=True, align="C")

    def set_background_color(self, r, g, b):
        self.set_fill_color(r, g, b)
        self.rect(0, 0, self.w, self.h, "F")

    def _sanitize_text(self, text):
        return ''.join(c if ord(c) < 256 else '?' for c in text)


def generate_pdf_id():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=8))

def generate_pdf(message, cookies, balance_info):
    chat_id = message.chat.id
    pdf = CustomPDF(chat_id)
    pdf.add_page()
    pdf.set_background_color(173, 216, 230)
    pdf.set_font("DejaVuSans", size=12)
    pdf.set_text_color(0, 0, 0)
    pdf.ln(10)

    first_name = sanitize_text(user_data[chat_id].get("first_name", "Unknown"))
    user_id = chat_id
    pdf_id = generate_pdf_id()

    # Add user details
    pdf.cell(0, 10, txt=f"Name: {first_name}", ln=True, align="L")
    pdf.cell(0, 10, txt=f"User Id: {user_id}", ln=True, align="L")
    pdf.cell(0, 10, txt=f"PDF Id: {pdf_id}", ln=True, align="L")
    pdf.ln(10)

    cookies_text = f"Cookies: {cookies[:8]}******{cookies[-8:]}"
    pdf.cell(0, 10, txt=sanitize_text(cookies_text), ln=True, align="C")
    pdf.ln(10)

    # Balance info in table
    pdf.cell(60, 10, "S No.", border=1, align="C")
    pdf.cell(60, 10, "Withdrawal Amount", border=1, align="C")
    pdf.cell(60, 10, "Total Balance", border=1, align="C")
    pdf.ln()
    pdf.cell(60, 10, "1", border=1, align="C")
    pdf.cell(60, 10, str(balance_info["withdrawal_amount"]), border=1, align="C")
    pdf.cell(60, 10, str(balance_info["total_balance"]), border=1, align="C")
    pdf.ln(20)

    final_note = "This is an autogenerated report. Don't share your PDF ID, as it is used to check your details and send you data."
    pdf.cell(0, 10, txt=sanitize_text(final_note), ln=True, align="C")
    pdf.output("xrp_balance_report.pdf")

def sanitize_text(text):
    return ''.join(c for c in text if ord(c) < 128)


@bot.on_message(filters.command("start") & filters.private)
async def start(client: Client, message: Message):
    chat_id = message.chat.id
    if chat_id in user_data:
        await message.reply_text(
            f"Welcome back, {message.from_user.first_name}!\n"
            "You already provided your cookies. Type /reset to reset your cookies or /mine to start mining."
        )
    else:
        user_data[chat_id] = {
            "first_name": message.from_user.first_name  # Store first name here
        }
        await message.reply_text("Send your cookies as plain text.")
        cookies = await client.listen(chat_id)
        user_data[chat_id]["cookies"] = cookies.text.strip()
        result = validate_and_fetch_user_info(user_data[chat_id]["cookies"])
        if "error" in result:
            await message.reply_text(f"Error: {result['error']}")
            del user_data[chat_id]
        else:
            user_data[chat_id].update(result)
            await message.reply_text(f"Cookies saved successfully for {result['username']}.")

@bot.on_message(filters.command("balance") & filters.private)
async def balance(client, message: Message):
    chat_id = message.chat.id
    if chat_id not in user_data or "cookies" not in user_data[chat_id]:
        await message.reply_text("Provide your cookies first. Type /start to begin.")
        return

    cookies = user_data[chat_id]["cookies"]
    balance_info = fetch_xrp_balance(cookies)
    if "error" in balance_info:
        await message.reply_text(f"Error fetching balance: {balance_info['error']}")
        return

    generate_pdf(message, cookies, balance_info)
    await client.send_document(chat_id, "xrp_balance_report.pdf")

async def main():
    try:
        await bot.start()
        print("Bot started!")
    except Exception as e:
        print(f"Failed to start bot: {e}")
    await idle()

if __name__ == "__main__":
    sync_time()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
