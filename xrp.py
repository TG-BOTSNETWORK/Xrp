import json
import requests
import asyncio
import os
import ntplib
from time import ctime, sleep
from pyrogram import filters, idle
from pyrogram.types import Message
from pyrogram import Client
from pyromod import listen
from fpdf import FPDF
import random
import string

bot = Client(
    "xrpminerbot",
    api_id=22363963,
    api_hash="5c096f7e8fd4c38c035d53dc5a85d768",
    bot_token="7261854045:AAGv8_bgcspRJ_LAMJjwaX_AAe8dSGMXEo4"
)

user_data = {}

def sync_time():
    try:
        ntp_client = ntplib.NTPClient()
        response = ntp_client.request('pool.ntp.org')
        os.system(f"date -s '{ctime(response.tx_time)}'")
        print("System time synchronized successfully.")
    except Exception as e:
        print(f"Failed to synchronize time: {e}")

def parse_cookies(cookie_string):
    cookies_dict = {}
    cookies = cookie_string.split(";")
    for cookie in cookies:
        if "=" in cookie:
            key, value = cookie.strip().split("=", 1)
            cookies_dict[key] = value
    return cookies_dict

def validate_and_fetch_user_info(cookie_string):
    session = requests.Session()
    session.headers.update({
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Content-Type': 'application/json',
        'Sec-Fetch-Dest': 'empty',
        'Sec-Fetch-Site': 'same-origin',
        'Sec-Fetch-Mode': 'cors',
        'Host': 'faucetearner.org',
        'Origin': 'https://faucetearner.org',
    })
    session.cookies.update(parse_cookies(cookie_string))

    try:
        response = session.get('https://faucetearner.org/api.php?act=faucet')
        
        if response.status_code == 200:
            try:
                user_info = response.json()
                email = user_info.get("email", "N/A")
                username = user_info.get("username", "N/A")
                return {"email": email, "username": username}
            except json.JSONDecodeError:
                return {"error": f"Invalid response format (expected JSON): {response.text}"}
        else:
            return {"error": f"HTTP Error: {response.status_code} - {response.text}"}
    except Exception as e:
        return {"error": f"Exception during login validation: {e}"}

def fetch_xrp_balance(cookie_string):
    session = requests.Session()
    session.headers.update({
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Content-Type': 'application/json',
        'Sec-Fetch-Dest': 'empty',
        'Sec-Fetch-Site': 'same-origin',
        'Sec-Fetch-Mode': 'cors',
        'Host': 'faucetearner.org',
        'Origin': 'https://faucetearner.org',
    })
    session.cookies.update(parse_cookies(cookie_string))

    try:
        response = session.get('https://faucetearner.org/api.php?act=withdraw')
        if response.status_code == 200:
            try:
                balance_info = response.json()
                withdrawal_amount = balance_info.get("withdrawal_amount", 0)
                total_balance = balance_info.get("total_balance", 0)
                status = balance_info.get("status", "Unknown")
                return {"withdrawal_amount": withdrawal_amount, "total_balance": total_balance, "status": status}
            except json.JSONDecodeError:
                return {"error": f"Invalid response format for balance: {response.text}"}
        else:
            return {"error": f"HTTP Error: {response.status_code} - {response.text}"}
    except Exception as e:
        return {"error": f"Exception during balance retrieval: {e}"}

class CustomPDF(FPDF):
    def header(self):
        self.set_font('Kanit', '', 12)
        self.cell(0, 10, 'XRP Balance Report', ln=True, align='C')
        self.ln(10)

    def footer(self):
        self.set_y(-30)
        self.set_font('Kanit', 'I', 10)
        self.cell(0, 10, 'Report generated by XRP Miner Bot - Created by Nobitha', ln=True, align='C')

    def add_watermark(self, text):
        self.set_font('Kanit', 'B', 50)
        self.set_text_color(200, 200, 200)
        self.rotate(45, x=55, y=100)
        self.text(50, 150, text)
        self.rotate(0)

    def set_background(self, image_path):
        self.image(image_path, x=0, y=0, w=self.w, h=self.h)

def generate_pdf(cookies, balance_info, user_info):
    pdf = CustomPDF()
    pdf.add_page()
    pdf.set_background('background.jpg')

    pdf.add_watermark('Trickopedia')

    pdf.set_font("Kanit", size=12)
    pdf.set_text_color(0, 0, 0)
    pdf.ln(40)

    pdf.cell(0, 10, txt=f"FIRST NAME: {user_info['first_name']}", ln=True, align="C")
    pdf.cell(0, 10, txt=f"USER ID: {user_info['user_id']}", ln=True, align="C")
    pdf.cell(0, 10, txt=f"PDF ID: {generate_pdf_id()}", ln=True, align="C")
    pdf.ln(10)

    pdf.cell(60, 10, "S No.", border=1, align="C")
    pdf.cell(60, 10, "Withdrawal Amount", border=1, align="C")
    pdf.cell(60, 10, "Total Balance", border=1, align="C")
    pdf.cell(60, 10, "Status", border=1, align="C")
    pdf.ln()

    pdf.cell(60, 10, "1", border=1, align="C")
    pdf.cell(60, 10, str(balance_info["withdrawal_amount"]), border=1, align="C")
    pdf.cell(60, 10, str(balance_info["total_balance"]), border=1, align="C")
    pdf.cell(60, 10, str(balance_info["status"]), border=1, align="C")
    pdf.ln(20)

    pdf.cell(0, 10, "This is an autogenerated report. Contact support for assistance.", ln=True, align="C")
    pdf.output("xrp_balance_report.pdf")

def generate_pdf_id():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=10))

def save_user_cookies_as_json(user_id, cookies):
    user_info = {"user_id": user_id, "cookies": cookies}
    with open(f"{user_id}_cookies.json", "w") as json_file:
        json.dump(user_info, json_file, indent=4)

@bot.on_message(filters.command("start") & filters.private)
async def start(client: Client, message: Message):
    chat_id = message.chat.id
    if chat_id in user_data:
        await message.reply_text(
            f"Welcome back, {message.from_user.first_name}!\n"
            "You already provided your cookies. Type /reset to reset your cookies or /mine to start mining."
        )
    else:
        user_data[chat_id] = {}
        await message.reply_text("Send your cookies as plain text.")
        cookies = await client.listen(chat_id)
        user_data[chat_id]["cookies"] = cookies.text.strip()
        result = validate_and_fetch_user_info(user_data[chat_id]["cookies"])
        
        if "error" in result:
            del user_data[chat_id]
            await message.reply_text(f"Invalid cookies: {result['error']}. Type /start to try again.")
        else:
            email = result["email"]
            username = result["username"]
            await message.reply_text(
                f"Cookies validated successfully!\n"
                f"Email: {email}\n"
                f"Username: {username}\n"
                "Type /mine to start mining."
            )
            user_data[chat_id]["email"] = email
            user_data[chat_id]["username"] = username
            save_user_cookies_as_json(chat_id, user_data[chat_id]["cookies"])
            await message.reply_text(f"Here are your cookies in JSON format: \n{json.dumps(user_data[chat_id]['cookies'], indent=4)}")

@bot.on_message(filters.command("mine") & filters.private)
async def mine(client, message):
    chat_id = message.chat.id
    if chat_id not in user_data or "cookies" not in user_data[chat_id]:
        await message.reply_text("Provide your cookies first. Type /start to begin.")
        return

    cookies = user_data[chat_id]["cookies"]
    result = validate_and_fetch_user_info(cookies)
    
    if "error" in result:
        await message.reply_text(f"Error: {result['error']}")
        return

    email = result["email"]
    username = result["username"]
    user_data[chat_id].update({"email": email, "username": username})

    await message.reply_text(
        f"Mining started for user:\nEmail: {email}\nUsername: {username}\n"
        "Fetching XRP balance..."
    )
    
    balance_info = fetch_xrp_balance(cookies)
    if "error" in balance_info:
        await message.reply_text(f"Error fetching balance: {balance_info['error']}")
        return
    
    generate_pdf(cookies, balance_info, user_data[chat_id])

    await message.reply_text("Your XRP balance report has been generated. Check your inbox for the PDF.")

@bot.on_message(filters.command("reset") & filters.private)
async def reset(client: Client, message: Message):
    chat_id = message.chat.id
    if chat_id in user_data:
        del user_data[chat_id]
        await message.reply_text("Your data has been reset. Type /start to begin again.")
    else:
        await message.reply_text("You haven't started yet. Type /start to begin.")

async def start_bot():
    sync_time()
    await bot.start()
    await idle()

loop = asyncio.get_event_loop()
loop.run_until_complete(start_bot())
