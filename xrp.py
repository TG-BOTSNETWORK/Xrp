import json
import requests
import asyncio
import os
import ntplib
from time import ctime, sleep
from pyrogram import filters, idle
from pyrogram.types import Message
from pyrogram import Client
from pyromod import listen
from fpdf import FPDF
import random
import string

bot = Client(
    "xrpminerbot",
    api_id=22363963,
    api_hash="5c096f7e8fd4c38c035d53dc5a85d768",
    bot_token="7261854045:AAGv8_bgcspRJ_LAMJjwaX_AAe8dSGMXEo4"
)

user_data = {}


def sync_time():
    try:
        ntp_client = ntplib.NTPClient()
        response = ntp_client.request('pool.ntp.org')
        os.system(f"date -s '{ctime(response.tx_time)}'")
        print("System time synchronized successfully.")
    except Exception as e:
        print(f"Failed to synchronize time: {e}")


def parse_cookies(cookie_string):
    cookies_dict = {}
    cookies = cookie_string.split(";")
    for cookie in cookies:
        if "=" in cookie:
            key, value = cookie.strip().split("=", 1)
            cookies_dict[key] = value
    return cookies_dict


def validate_and_fetch_user_info(cookie_string):
    session = requests.Session()
    session.headers.update({
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Content-Type': 'application/json',
        'Sec-Fetch-Dest': 'empty',
        'Sec-Fetch-Site': 'same-origin',
        'Sec-Fetch-Mode': 'cors',
        'Host': 'faucetearner.org',
        'Origin': 'https://faucetearner.org',
    })
    session.cookies.update(parse_cookies(cookie_string))

    try:
        response = session.get('https://faucetearner.org/api.php?act=faucet')

        if response.status_code == 200:
            try:
                user_info = response.json()
                email = user_info.get("email", "N/A")
                username = user_info.get("username", "N/A")
                return {"email": email, "username": username}
            except json.JSONDecodeError:
                return {"error": f"Invalid response format (expected JSON): {response.text}"}
        else:
            return {"error": f"HTTP Error: {response.status_code} - {response.text}"}
    except Exception as e:
        return {"error": f"Exception during login validation: {e}"}


def fetch_xrp_balance(cookie_string):
    session = requests.Session()
    session.headers.update({
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Content-Type': 'application/json',
        'Sec-Fetch-Dest': 'empty',
        'Sec-Fetch-Site': 'same-origin',
        'Sec-Fetch-Mode': 'cors',
        'Host': 'faucetearner.org',
        'Origin': 'https://faucetearner.org',
    })
    session.cookies.update(parse_cookies(cookie_string))

    try:
        response = session.get('https://faucetearner.org/api.php?act=withdraw')
        if response.status_code == 200:
            try:
                balance_info = response.json()
                withdrawal_amount = balance_info.get("withdrawal_amount", 0)
                total_balance = balance_info.get("total_balance", 0)
                return {"withdrawal_amount": withdrawal_amount, "total_balance": total_balance}
            except json.JSONDecodeError:
                return {"error": f"Invalid response format for balance: {response.text}"}
        else:
            return {"error": f"HTTP Error: {response.status_code} - {response.text}"}
    except Exception as e:
        return {"error": f"Exception during balance retrieval: {e}"}


class CustomPDF(FPDF):
    def __init__(self, chat_id, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.chat_id = chat_id
        # Add a UTF-8 compatible font
        self.add_font('DejaVu', '', 'assets/DejaVuSans.ttf, uni=True)
        self.set_font('DejaVu', '', 12)

    def header(self):
        self.set_font('DejaVu', 'B', 12)
        self.cell(0, 10, f"FIRST NAME: {user_data[self.chat_id]['first_name']}   User ID: {self.chat_id}   PDF ID: {generate_pdf_id()}", ln=True, align='C')
        self.ln(10)

    def footer(self):
        self.set_y(-30)
        self.set_font('DejaVu', 'I', 10)
        self.cell(0, 10, 'Report generated by XRP Miner Bot - Created by Nobitha', ln=True, align='C')

    def add_watermark(self, text):
        self.set_font('DejaVu', 'B', 50)
        self.set_text_color(200, 200, 200)
        self.rotate(45, x=55, y=100)
        self.text(50, 150, text)
        self.rotate(0)

    def set_background(self, image_path):
        self.image(image_path, x=0, y=0, w=self.w, h=self.h)


def generate_pdf_id():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=8))


def generate_pdf(message, cookies, balance_info):
    chat_id = message.chat.id
    pdf = CustomPDF(chat_id)
    pdf.add_page()
    pdf.set_background('background.jpg')
    pdf.add_watermark('XRP MINER BY NOBITHA')
    pdf.set_font("DejaVu", size=12)
    pdf.set_text_color(0, 0, 0)
    pdf.ln(40)
    pdf.cell(0, 10, txt=f"Cookies: {cookies[:8]}******{cookies[-8:]}", ln=True, align="C")
    pdf.ln(10)
    pdf.cell(60, 10, "S No.", border=1, align="C")
    pdf.cell(60, 10, "Withdrawal Amount", border=1, align="C")
    pdf.cell(60, 10, "Total Balance", border=1, align="C")
    pdf.ln()
    pdf.cell(60, 10, "1", border=1, align="C")
    pdf.cell(60, 10, str(balance_info["withdrawal_amount"]), border=1, align="C")
    pdf.cell(60, 10, str(balance_info["total_balance"]), border=1, align="C")
    pdf.ln(20)
    pdf.cell(0, 10, "This is an autogenerated report. Contact support for assistance.", ln=True, align="C")
    pdf.output("xrp_balance_report.pdf")


@bot.on_message(filters.command("start") & filters.private)
async def start(client: Client, message: Message):
    chat_id = message.chat.id
    if chat_id in user_data:
        await message.reply_text(
            f"Welcome back, {message.from_user.first_name}!\n"
            "You already provided your cookies. Type /reset to reset your cookies or /mine to start mining."
        )
    else:
        user_data[chat_id] = {}
        await message.reply_text("Send your cookies as plain text.")
        cookies = await client.listen(chat_id)
        user_data[chat_id]["cookies"] = cookies.text.strip()
        result = validate_and_fetch_user_info(user_data[chat_id]["cookies"])
        
        if "error" in result:
            del user_data[chat_id]
            await message.reply_text(f"Invalid cookies: {result['error']}. Type /start to try again.")
        else:
            email = result["email"]
            username = result["username"]
            user_data[chat_id]["email"] = email
            user_data[chat_id]["username"] = username
            user_data[chat_id]["first_name"] = message.from_user.first_name
            await message.reply_text(
                f"Cookies validated successfully!\n"
                f"Email: {email}\n"
                f"Username: {username}\n"
                "Type /mine to start mining."
            )


@bot.on_message(filters.command("mine") & filters.private)
async def mine(client, message):
    chat_id = message.chat.id
    if chat_id not in user_data or "cookies" not in user_data[chat_id]:
        await message.reply_text("Provide your cookies first. Type /start to begin.")
        return

    cookies = user_data[chat_id]["cookies"]
    result = validate_and_fetch_user_info(cookies)
    
    if "error" in result:
        await message.reply_text(f"Error: {result['error']}")
        return

    email = result["email"]
    username = result["username"]
    user_data[chat_id].update({"email": email, "username": username})
    balance_info = fetch_xrp_balance(cookies)
    if "error" in balance_info:
        await message.reply_text(f"Error: {balance_info['error']}")
        return

    generate_pdf(message, cookies, balance_info)
    await client.send_document(chat_id, "xrp_balance_report.pdf")
    os.remove("xrp_balance_report.pdf")


@bot.on_message(filters.command("reset") & filters.private)
async def reset(client, message):
    chat_id = message.chat.id
    if chat_id in user_data:
        del user_data[chat_id]
        await message.reply_text("Cookies reset. Type /start to provide new cookies.")
    else:
        await message.reply_text("No cookies found. Type /start to provide cookies.")


@bot.on_message(filters.command("help") & filters.private)
async def help(client, message):
    await message.reply_text(
        "Available Commands:\n"
        "/start - Start the bot and provide cookies\n"
        "/mine - Start mining\n"
        "/reset - Reset your cookies\n"
        "/help - Show help information"
    )


if __name__ == "__main__":
    sync_time()
    bot.start()
    print("Bot started!")
    idle()
